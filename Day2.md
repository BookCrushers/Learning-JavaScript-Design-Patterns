# 인사이트

## Day2

### Elio

#### 내용 정리

- 모듈
  - 애플리케이션을 구성하는 단위
  - 모듈형 애플리케이션은 잘게 분리된 모듈로 구성되었다는 의미
    - 의존성이 낮아져 유지보수 용이하게 만듦
  - 이전 자바스크립트에는 모듈을 가져올 수 있는 방법이 없었음
  - 정교한 모듈 시스템의 필요성으로 인해 문제 발생
  - 초기에는 AMD, CommonJS 도입
  - ES6, ES2015에서 모듈 관련 기능 추가됨
  - ES2015 출시와 함께 모듈은 표준화됨
  - mjs
    - 모듈과 기존 스크립트를 구분하기 위한 확장자
    - 런타임 및 빌드 도구에 모듈임을 알릴 수 있음
  - nomodule
    - script 태그의 nomodule 속성은 모듈이 아님을 명시
    - 모듈을 지원하지 않는 브라우저에서도 동작하게끔 함
  - IntersectionObserver API
    - 컴포넌트가 화면에 보일 때 감지 가능
  - 장점
    - 한 번만 실행됨
    - 자동으로 지연 로드
    - 유지보수와 재사용 쉬움
    - 네임스페이스 제공
    - 사용하지 않는 코드 제거
      - 트리쉐이킹이라고 부름

#### 인사이트

- 이미 표준화된 모듈을 왜 굳이 mjs로 표현하는지?
  - 기존 모듈 시스템 CommonJS와의 구분을 위해
- https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/
  - **종속성 그래프 구축**
    모듈 시스템은 `import` 관계를 바탕으로 종속성 그래프를 생성
  - 이 그래프는 애플리케이션의 진입점부터 모든 의존 모듈을 연결한 구조
  - **진입점은 import**
    애플리케이션의 시작 파일(진입점)은 보통 `import` 문을 통해 다른 모듈과 연결되며, 종속성 그래프를 확장
  - **JS 파일 자체는 브라우저가 사용할 수 없음**
  - **모듈 레코드라는 데이터 구조로 변경 필요**
    로드된 모듈 파일은 "모듈 레코드"라는 내부 데이터 구조로 변환되며, 이를 기반으로 모듈의 구문 분석이 진행됨
  - **모듈 레코드는 모듈 인스턴스로 변환**
    모듈 레코드는 실행 가능한 모듈 인스턴스로 변환됨. 이는 코드와 상태를 포함
  - **모듈 인스턴스는 아래 두 가지 요소를 가짐**
    - **코드**: 모듈 내 명령어와 실행 논리.
    - **상태**: 모든 변수와 메모리 공간.
  - **모듈 로딩 프로세스**
    - 구성
      - 모든 모듈 파일을 찾아 다운로드하고, 이를 "모듈 레코드"로 구문 분석합니다.
    - 인스턴스화
      - 각 모듈의 변수와 `import`/`export`를 연결하며, 메모리 공간을 할당. 이를 **Linking**이라고 함
    - 평가
      - 코드를 실행하여 각 변수와 함수가 실제 값을 가지도록 메모리 공간을 채움


## Day2

### Dennis

#### 내용 정리

**최신 자바스크립트의 문법과 기능**

자바스크립트에 모듈화를 지원하기위해서 AMD와 CommonJS 모듈이 많이 사용되었다.

현대에 이르러서 자바스크립트는 다양한 모듈 import와 export 방식을 제공한다.
- 모듈을 객체로 가져오는법
- 정적으로 모듈을 가져오는법
- 외부 소스로부터 모듈을 가져오는법
- 동적으로 모듈을 가져오는법

모듈을 동적으로 가져오게 되면서 다음와 같이 응용해서 사용할 수 있게 되었다.
- 사용자의 인터랙션에 따른 다이나믹 import
- intersectionObserver API 를 화면의 노출 정도에 따른 다이다믹 import

Node 15.3.0 버전에서는 정식으로 자바스크립트 모듈을 제공한다.

**모듈화를 통해서 얻을 수 있는 이점**
- 한번만 실행된다.
- 자동으로 지연 로드된다.
- 유지보수와 재사용이 쉽다.
- 네임스페이스를 제공한다.
- 사용하지 않는 코드를 제거한다.

**디자인 패턴의 유형**
디자인 패턴은 어떤 문제를 해결하냐에 따라 세가지 유형으로 나뉜다
- 생성 패턴
  - 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둠
- 구조 패턴
  - 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둠
- 행위 패턴
  - 객체간의 커뮤니티를 간소화하거나 개선하는데 중점을 둠

***

#### 인사이트

현대에 보통의 자바스크립트에서 사용되는 모듈 방식은 ESM이다.

ESM의 동작 방식은 의존성 그래프를 기반으로 구성, 인스턴스화, 평가의 3단계를 거치게된다.

**구성**
- 모듈 파일의 위치를 파악하고 다운로드, script 태그와 import 문을 통해 의존성을 탐색.

**인스턴스화**
- 모듈 레코드를 모듈 인스턴스로 변환
- export와 import가 같은 메모리 주소를 가리켜 변경사항을 동기화

**평가**
- 코드를 실행해 메모리 공간을 실제 값으로 채움

export한 모듈은 const처럼 동작
원시값을 export로 내보내면 수정 불가, 객체를 내보내면 안의 속성 값은 수정 가능
참조값을 수정할 수 없음

***
