# 인사이트

## Day2

### Elio

#### 내용 정리

- 모듈
  - 애플리케이션을 구성하는 단위
  - 모듈형 애플리케이션은 잘게 분리된 모듈로 구성되었다는 의미
    - 의존성이 낮아져 유지보수 용이하게 만듦
  - 이전 자바스크립트에는 모듈을 가져올 수 있는 방법이 없었음
  - 정교한 모듈 시스템의 필요성으로 인해 문제 발생
  - 초기에는 AMD, CommonJS 도입
  - ES6, ES2015에서 모듈 관련 기능 추가됨
  - ES2015 출시와 함께 모듈은 표준화됨
  - mjs
    - 모듈과 기존 스크립트를 구분하기 위한 확장자
    - 런타임 및 빌드 도구에 모듈임을 알릴 수 있음
  - nomodule
    - script 태그의 nomodule 속성은 모듈이 아님을 명시
    - 모듈을 지원하지 않는 브라우저에서도 동작하게끔 함
  - IntersectionObserver API
    - 컴포넌트가 화면에 보일 때 감지 가능
  - 장점
    - 한 번만 실행됨
    - 자동으로 지연 로드
    - 유지보수와 재사용 쉬움
    - 네임스페이스 제공
    - 사용하지 않는 코드 제거
      - 트리쉐이킹이라고 부름

#### 인사이트

- 이미 표준화된 모듈을 왜 굳이 mjs로 표현하는지?
  - 기존 모듈 시스템 CommonJS와의 구분을 위해
- https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/
  - **종속성 그래프 구축**
    모듈 시스템은 `import` 관계를 바탕으로 종속성 그래프를 생성
  - 이 그래프는 애플리케이션의 진입점부터 모든 의존 모듈을 연결한 구조
  - **진입점은 import**
    애플리케이션의 시작 파일(진입점)은 보통 `import` 문을 통해 다른 모듈과 연결되며, 종속성 그래프를 확장
  - **JS 파일 자체는 브라우저가 사용할 수 없음**
  - **모듈 레코드라는 데이터 구조로 변경 필요**
    로드된 모듈 파일은 "모듈 레코드"라는 내부 데이터 구조로 변환되며, 이를 기반으로 모듈의 구문 분석이 진행됨
  - **모듈 레코드는 모듈 인스턴스로 변환**
    모듈 레코드는 실행 가능한 모듈 인스턴스로 변환됨. 이는 코드와 상태를 포함
  - **모듈 인스턴스는 아래 두 가지 요소를 가짐**
    - **코드**: 모듈 내 명령어와 실행 논리.
    - **상태**: 모든 변수와 메모리 공간.
  - **모듈 로딩 프로세스**
    - 구성
      - 모든 모듈 파일을 찾아 다운로드하고, 이를 "모듈 레코드"로 구문 분석합니다.
    - 인스턴스화
      - 각 모듈의 변수와 `import`/`export`를 연결하며, 메모리 공간을 할당. 이를 **Linking**이라고 함
    - 평가
      - 코드를 실행하여 각 변수와 함수가 실제 값을 가지도록 메모리 공간을 채움
