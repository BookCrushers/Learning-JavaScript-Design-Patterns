## Day3

### Elio

#### ✈️ 내용 정리

##### 생성 패턴

- 생성자 패턴

  - 생성자란 객체가 새로 만들어진 뒤 초기화하는 데에 사용되는 메서드
  - 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 문법적 설탕

- 객체 생성

  - 리터럴 표기법 사용
  - Object.create() 사용
  - new 키워드를 사용하여 빈 객체 생성

- 생성자 기본 특징

  - 단점
    - **상속이 어려워짐**
    - 객체를 생성할 때마다 메서드를 새로 정의함

- 프로토타입을 가진 생성자

  - 여러 개의 객체를 생성할 경우, prototype을 사용하면 공통 메서드를 쉽게 정의 가능

- 모듈 패턴

  - 클래스의 캡슐화를 위해 처음 고안됨
  - 비공개
    - 모듈 패턴은 클러즈를 활용해 비공개 상태와 구성을 캡슐화
    - ES2019 이전의 자바스크립트에서는 접근 제한자를 지원하지 않아 비공개라는 개념이 존재하지 않음
    - 당시에는 함수 스코프를 이용해 비공개 개념을 구현
    - 반환된 객체에 포함된 변수를 비공개하려면 WeakMap을 사용
  - 예제
    - 모듈 내부의 함수를 직접 읽지 못함
    - export를 하지 않은 변수는 전역 스코프로부터 완전히 보호되어 비공개 변수로 작동
    - 모듈의 클로저 내부로 스코프가 제한되기 때문에 모듈에 접근해야만 모듈 내부의 함수에 접근 가능
    - 모듈 내부에 메서드를 정의
      - 모듈 네임으로 네임스페이스가 지정됨
      - 이점
        - 비공개 자유성
        - 디버깅 용이성

- 모듈 패턴의 변형

  - 믹스인 가져오기 변형
    - 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달할 수 있게끔 함
    - 고차함수
      - 함수를 파라미터로 전달받거나 연산의 결과로 반환해주는 메서드
  - 내보내기 변형
    - default 키워드를 사용하면 이름을 지정하지 않고 전역 스코프로 변수를 내보냄
  - 장점
    - 이해하기 쉬움
    - 비공개 지원
    - 캡슐화 가능
  - 단점
    - 공개, 비공개 멤버를 다르게 접근해야 함
    - 나중에 추가한 메서드에서는 비공개 멤버에 접근 불가
    - 유닛 테스트에서 비공개 멤버는 제외됨
    - 핫 픽스가 필요한 오류를 고칠 때 복잡도를 높임
      - 빠른 수정이 필요한 경우, 그저 비공개 멤버를 수정하는 건 불가능하기 때문에 복잡도가 높아짐

- WeakMap을 사용하는 최신 모듈 패턴

  - 장점
    - WeakMap은 기본적으로 키가 약하게 유지되는 맵으로 참조되지 않는 키는 가비지 컬렉션의 대상이 됨
    - 기존 모듈 패턴에서는 클로저를 남발할 경우, 메모리 누수의 위험이 있지만 WeakMap은 이를 해결

- 노출 모듈 패턴

  - default를 사용하는 패턴
  - **앞에서 설명한 것과 뭐가 다른지?**

- 싱글톤

  - 클래스 인스턴스가 하나만 존재하도록 하는 패턴
  - 특징
    - 인스턴스에 대한 전역 접근 허용
  - 적합성
    - 인스턴스는 하나만 있어야 하며 접근 용이해야 함
    - 서브 클래싱을 통해서만 확장할 수 있어야 하고, 코드의 수정 없이 확장된 인스턴스 사용 가능
      - "싱글톤은 서브 클래싱을 통해서만 기능을 확장한다"는 것은 싱글톤 패턴의 **단일 인스턴스 제약을 유지하면서 새로운 기능을 추가하거나 기존 기능을 변경**하기 위해서는 **서브 클래스를 생성해야 한다**는 의미
      - **싱글톤 클래스에 알맞은 기능을 추가한다면 굳이 서브 클래싱을 사용할 이유가?**
      - 기존 클래스를 유지하면서 확장할 때만 사용하는 걸로 이해
  - 싱글톤은 유용하나 그냥 자바스크립트 객체 하나로도 대체 가능
  - 단점
    - 싱글톤 파악하기 어려움
    - 테스트하기 힘듦
    - 신중한 조정 필요

- 프로토타입

  - 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
  - 클래스처럼 따로 정의되는 것이 아니라 이미 존재하는 다른 객체를 복제하는 것
  - 장점
    - 자바스크립트만의 고유한 방식으로 작업 가능
    - 상속을 쉽게 구현할 수 있으며 성능상 이점도 있음
    - 객체 내 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있음(앞에서 언급한 내용)
  - 클래스와 생성자도 결국은 함수와 프로토타입으로 컴파일됨
  - Object.create를 사용

- 팩토리 패턴

  - 생성자를 필요로 하지 않음

  - 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 유용

  - ```js
    class Car {
      constructor({ doors = 4, state = 'new', color = 'silver' } = {}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
      }
    }
    // 디스트럭처링을 이용한 초기화 로직
    ```

- 팩토리 패턴 사용하면 좋은 상황

  - 객체나 컴포넌트 생성 과정이 복잡할 때

  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 방법이 필요할 때

  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때

  - **덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용**

    - **동적 타이핑의 한 종류**로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정

    - 아래 코드를 보면 duck과 dog는 타입이 아니라 메서드를 가진 객체일뿐

    - ```js
      function makeSound(animal) {
        if (animal.quack) {
          animal.quack();
        } else if (animal.bark) {
          animal.bark();
        } else {
          console.log('Unknown sound');
        }
      }
      
      const duck = {
        quack() {
          console.log('Quack! Quack!');
        }
      };
      
      const dog = {
        bark() {
          console.log('Woof! Woof!');
        }
      };
      
      makeSound(duck); // Quack! Quack!
      makeSound(dog);  // Woof! Woof!
      ```

    - 디커플링

      - 한 부분의 변경이 다른 부분에 영향을 미치지 않도록 분리

- 팩토리 패턴 사용하면 안 되는 상황

  - 객체 생성 인터페이스 제공이 설계 목표가 아닌 경우
  - 단위 테스트시 복잡성 증가

- 추상 팩토리 패턴

  - 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
  - 객체가 어떻게 생성되는지에 대해 알 필요 없음
  - 객체 생성 과정에 영향을 받지 않거나 여러 타입 객체로 작업할 때 사용

- 구조 패턴

  - 퍼사드
  - 믹스인
  - 데코레이터
  - 플라이웨이트

- 퍼사드

  - 실제 모습을 숨기고 꾸며낸 겉모습만을 드러내는 것을 뜻함
  - 외부에 제공되는 API 단순화

- 믹스인

  - 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 해주는 클래스
  - 다중 상속의 대안으로 자주 사용되며, 하나의 클래스로 상속받을 수 없는 공통 동작이나 기능을 다른 클래스에 혼합(믹스)하기 위해 활용

#### 👀 인사이트
- 내용정리 중 볼드 처리 이야기해보기

***

### Dennis

#### ✈️ 내용 정리
7.1 ~ 7.10 

생성패턴
- 생성자 패턴
    - 생성자 함수를 통하여 초기화 및 객체를 생성해낼 수 있는 패턴
    - 자바스크립트는 ES2015의 클래스 문법을 통해서 constructor 함수를 활용할 수 있다.
    - 이전에는 프로토타입을 가지고 생성하거나 직접 객체 리터럴을 다뤄야했다.
- 모듈 패턴
    - 클래스의 캡슐화를 위해 만들어진 패턴
    - 자바스크립트의 모듈 패턴은 클로저를 활요해 "비공개" 상태와 구성을 캡슐화한다.
    - 현대의 자바스크립트(ES2019) 에서는 접근 제한자(#, 해시)를 통해 비공개 변수를 선언한다.
    - 단점
        - 나중에 추가한 메서드에서 비공개 멤버 접근 불가능
        - 단위 테스트에서 비공게 맴버는 제외됨
        - 핫 픽스에서 디버깅 시 복잡도가 높음
    - WeakMap을 통해서 간략화한 비공개 변수를 다룰 수 있음
- 노출 모듈 패턴
    - 모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 변수나 함수만 익명 객체에 담아서 반환하는 패턴
    - JS에선 ES2015+ 모듈 스코프안에 정의된 함수와 변수는 모두 비공개처리, export를 통해서 공개해야하니 자연스럽게 노출 모듈 패턴을 사용하고 있음음
- 싱글톤 패턴
    - 클래스의 인스턴스를 오직 하나만 존재하도록 제한하는 패턴
    - 적합성
        - 클래스의 인스턴스는 정확히 하나만 있어야한다.
        - 잘 보이는곳에 위치시켜 접근을 용이하게 해야한다.
        - 서브클래싱을 통해서만 확장할 수 있어야한다.
        - 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야한다.
    - C++이나 자바와는 달리 자바스크립트는 객체를 직접 생성할 수 있기 때문에 굳이 싱글톤 클랙스를 만들 필요는 없을 수 있다.
- 프로토타입 패턴
    - 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴턴
    - 프로토타입과 클래스는 엄연히 다르다.
- 팩토리 패턴
    - 객체를 생성하는 패턴, 다른 패턴과 달리 생성자를 필요로 하지 않는다.
    - 유용한 상황
        - 객체나 컴포넌트의 생성 과정이 높은 복잡성을 갖음
        - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요함
        - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야함
        - 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인슨턴스와 함께 객체를 구성할때, 또한 디커플링에도 유용함
- 추상 팩토리 패턴
    - 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴

구조패턴
- 퍼사드 패턴
    - 심층적인 복잡성을 숨기고, 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴
    - 단독으로만 사용해야만 하는것은 아님, 모듈 패턴과 같이 다른 패턴과도 어울릴 수 있음

- 믹스인 패턴
    - 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스
    - C++이나 Lisp같은 전통적인 프로그래밍 언어에서 사용됨

#### 👀 인사이트

**WeakMap** : 키가 약하게 유지되는 맵 즉, 약한 참조를 지닌 키

디자인 패턴이라는게 생각보다 많은곳에서 이미 자연스럽게 사용하고 있었다는 점

**차등 상속**
상위 클래스의 기능과 속성을 하위 클래스에서 선택적으로 상속하거나 재정의하여, 각 하위 클래스가 자신의 요구에 맞는 고유한 동작과 특성을 가질 수 있도록 하는 설계 방식


**[OOAD(Object Oriented Analysis and Design)](https://travel-diary.tistory.com/4)원칙**

- 객체 지향 분석(OOA) 와 객체지향 설계(OOD)가 합쳐진 "객체지향적인 분석과 설계 방법" 이다.

    - 객체지향 분석 (Object Oriented Analysis)
    - 문제를 정의하고 이 정의로부터 개념 모델(객체에 대한 추상적 정의)을 사용하여 객체, 관계 및 동작을 식별한다.

    - 객체지향 설계 (Object Oriented Design)
    - 설계 단계에서는 객체와 그들의 속성(attribute), 동작(behavior), 상호작용(interaction)을 설명한다.