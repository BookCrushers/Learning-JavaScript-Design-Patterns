# 인사이트

## Day3

### Elio

#### 내용 정리

##### 생성 패턴

- 생성자 패턴

  - 생성자란 객체가 새로 만들어진 뒤 초기화하는 데에 사용되는 메서드
  - 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 문법적 설탕

- 객체 생성

  - 리터럴 표기법 사용
  - Object.create() 사용
  - new 키워드를 사용하여 빈 객체 생성

- 생성자 기본 특징

  - 단점
    - **상속이 어려워짐**
    - 객체를 생성할 때마다 메서드를 새로 정의함

- 프로토타입을 가진 생성자

  - 여러 개의 객체를 생성할 경우, prototype을 사용하면 공통 메서드를 쉽게 정의 가능

- 모듈 패턴

  - 클래스의 캡슐화를 위해 처음 고안됨
  - 비공개
    - 모듈 패턴은 클러즈를 활용해 비공개 상태와 구성을 캡슐화
    - ES2019 이전의 자바스크립트에서는 접근 제한자를 지원하지 않아 비공개라는 개념이 존재하지 않음
    - 당시에는 함수 스코프를 이용해 비공개 개념을 구현
    - 반환된 객체에 포함된 변수를 비공개하려면 WeakMap을 사용
  - 예제
    - 모듈 내부의 함수를 직접 읽지 못함
    - export를 하지 않은 변수는 전역 스코프로부터 완전히 보호되어 비공개 변수로 작동
    - 모듈의 클로저 내부로 스코프가 제한되기 때문에 모듈에 접근해야만 모듈 내부의 함수에 접근 가능
    - 모듈 내부에 메서드를 정의
      - 모듈 네임으로 네임스페이스가 지정됨
      - 이점
        - 비공개 자유성
        - 디버깅 용이성

- 모듈 패턴의 변형

  - 믹스인 가져오기 변형
    - 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달할 수 있게끔 함
    - 고차함수
      - 함수를 파라미터로 전달받거나 연산의 결과로 반환해주는 메서드
  - 내보내기 변형
    - default 키워드를 사용하면 이름을 지정하지 않고 전역 스코프로 변수를 내보냄
  - 장점
    - 이해하기 쉬움
    - 비공개 지원
    - 캡슐화 가능
  - 단점
    - 공개, 비공개 멤버를 다르게 접근해야 함
    - 나중에 추가한 메서드에서는 비공개 멤버에 접근 불가
    - 유닛 테스트에서 비공개 멤버는 제외됨
    - 핫 픽스가 필요한 오류를 고칠 때 복잡도를 높임
      - 빠른 수정이 필요한 경우, 그저 비공개 멤버를 수정하는 건 불가능하기 때문에 복잡도가 높아짐

- WeakMap을 사용하는 최신 모듈 패턴

  - 장점
    - WeakMap은 기본적으로 키가 약하게 유지되는 맵으로 참조되지 않는 키는 가비지 컬렉션의 대상이 됨
    - 기존 모듈 패턴에서는 클로저를 남발할 경우, 메모리 누수의 위험이 있지만 WeakMap은 이를 해결

- 노출 모듈 패턴

  - default를 사용하는 패턴
  - **앞에서 설명한 것과 뭐가 다른지?**

- 싱글톤

  - 클래스 인스턴스가 하나만 존재하도록 하는 패턴
  - 특징
    - 인스턴스에 대한 전역 접근 허용
  - 적합성
    - 인스턴스는 하나만 있어야 하며 접근 용이해야 함
    - 서브 클래싱을 통해서만 확장할 수 있어야 하고, 코드의 수정 없이 확장된 인스턴스 사용 가능
      - "싱글톤은 서브 클래싱을 통해서만 기능을 확장한다"는 것은 싱글톤 패턴의 **단일 인스턴스 제약을 유지하면서 새로운 기능을 추가하거나 기존 기능을 변경**하기 위해서는 **서브 클래스를 생성해야 한다**는 의미
      - **싱글톤 클래스에 알맞은 기능을 추가한다면 굳이 서브 클래싱을 사용할 이유가?**
      - 기존 클래스를 유지하면서 확장할 때만 사용하는 걸로 이해
  - 싱글톤은 유용하나 그냥 자바스크립트 객체 하나로도 대체 가능
  - 단점
    - 싱글톤 파악하기 어려움
    - 테스트하기 힘듦
    - 신중한 조정 필요

- 프로토타입

  - 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
  - 클래스처럼 따로 정의되는 것이 아니라 이미 존재하는 다른 객체를 복제하는 것
  - 장점
    - 자바스크립트만의 고유한 방식으로 작업 가능
    - 상속을 쉽게 구현할 수 있으며 성능상 이점도 있음
    - 객체 내 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있음(앞에서 언급한 내용)
  - 클래스와 생성자도 결국은 함수와 프로토타입으로 컴파일됨
  - Object.create를 사용

- 팩토리 패턴

  - 생성자를 필요로 하지 않음

  - 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 유용

  - ```js
    class Car {
      constructor({ doors = 4, state = 'new', color = 'silver' } = {}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
      }
    }
    // 디스트럭처링을 이용한 초기화 로직
    ```

- 팩토리 패턴 사용하면 좋은 상황

  - 객체나 컴포넌트 생성 과정이 복잡할 때

  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 방법이 필요할 때

  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때

  - **덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용**

    - **동적 타이핑의 한 종류**로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정

    - 아래 코드를 보면 duck과 dog는 타입이 아니라 메서드를 가진 객체일뿐

    - ```js
      function makeSound(animal) {
        if (animal.quack) {
          animal.quack();
        } else if (animal.bark) {
          animal.bark();
        } else {
          console.log('Unknown sound');
        }
      }
      
      const duck = {
        quack() {
          console.log('Quack! Quack!');
        }
      };
      
      const dog = {
        bark() {
          console.log('Woof! Woof!');
        }
      };
      
      makeSound(duck); // Quack! Quack!
      makeSound(dog);  // Woof! Woof!
      ```

    - 디커플링

      - 한 부분의 변경이 다른 부분에 영향을 미치지 않도록 분리

- 팩토리 패턴 사용하면 안 되는 상황

  - 객체 생성 인터페이스 제공이 설계 목표가 아닌 경우
  - 단위 테스트시 복잡성 증가

- 추상 팩토리 패턴

  - 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
  - 객체가 어떻게 생성되는지에 대해 알 필요 없음
  - 객체 생성 과정에 영향을 받지 않거나 여러 타입 객체로 작업할 때 사용

- 구조 패턴

  - 퍼사드
  - 믹스인
  - 데코레이터
  - 플라이웨이트

- 퍼사드

  - 실제 모습을 숨기고 꾸며낸 겉모습만을 드러내는 것을 뜻함
  - 외부에 제공되는 API 단순화

- 믹스인

  - 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 해주는 클래스
  - 다중 상속의 대안으로 자주 사용되며, 하나의 클래스로 상속받을 수 없는 공통 동작이나 기능을 다른 클래스에 혼합(믹스)하기 위해 활용

#### 인사이트

- 내용정리 중 볼드 처리 이야기해보기

***

### Dennis

#### 내용 정리



#### 인사이트

