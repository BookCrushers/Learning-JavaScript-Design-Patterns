## Day9

### Elio

#### ✈️ 내용 정리

- 네임스페이스란 코드 단위를 고유한 식별자로 그룹화한 것을 뜻함
- 하나의 식별자를 여러 네임스페이스에서 참조 가능
- 각 식별자는 중첩된 네임스페이스의 계층구조를 가질 수 있음
- 대규모 스크립트나 애플리케이션에서는 네임스페이스가 매우 중요
- 변수 또는 메서드 이름이 충돌하여 코드가 실행되지 않는 문제 방지
- 네임스페이스를 지원하지는 않지만 객체와 클로저를 활용해 비슷한 기능 사용 가능

#### 네임스페이스 기초

- 단일 전역 변수
- 접두사 네임스페이스
- 객체 리터럴 표기법
- 중첩 네임스페이스
- 즉시 실행 함수 표현식
- 네임스페이스 주입

#### 단일 전역 변수 패턴

- 하나의 전역 변수를 주요 참조 객체로 사용
- 다른 개발자가 같은 이름의 전역 변수를 사용한다면 충돌 발생

#### 접두사 네임스페이스 패턴

- 고유한 접두사를 선정한 후 모든 메서드, 변수, 객체를 이 접두사 뒤에 붙여서 정의
- 가장 큰 문제는 애플리케이션의 규모가 커질수록 많은 전역 객체가 생성된다는 점

#### 객체 리터럴 표기법 패턴

- 전역 네임스페이스를 오염시키지 않으면서 코드와 매개변수를 논리적으로 구성하는 데 도움을 줌
- 일반적인 전역 변수들과 달리 동일한 이름의 변수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성을 크게 줄여줌

#### 즉시 실행 함수 표현식 패턴

- 즉시 실행 함수는 정의 직후 바로 실행되는, 이름이 없는 함수
- 즉시 실행 함수로 정의된 내부의 변수와 함수 모두 외부에서 접근할 수 없어 은닉성을 쉽게 구현 가능

#### 네임스페이스 주입 패턴

- 즉시 실행 함수 패턴의 또 다른 변형
- 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에 메서드와 속성을 주입
- 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다는 점
- 기본 메서드에 적용할 때 유용

#### 고급 네임스페이스 패턴

##### 중첩 네임스페이스 자동화 패턴

- 하나의 문자열 인자를 받아 파싱한 뒤에 필요한 객체를 기반 네임스페이스에 자동으로 추가

##### 의존성 선언 패턴

- 객체에 대한 로컬 참조가 전체적인 조회 시간을 낮춤
- 함수나 모듈에서 사용할 로컬 네임스페이스를 정의하는 것이 의존성 선언 패턴
- 의존성을 찾고 해석하는 시간을 줄임
- 동적으로 모듈을 네임스페이스에 추가하는 확장 가능한 아키텍처를 사용하는 경우에도 효과적

##### 심층 객체 확장 패턴

- lodash의 extend()
- jQuery를 사용한다면 $.extend 사용 가능

#### 👀 인사이트

| 특징      | 네임스페이스                             | 모듈                                 |
| --------- | ---------------------------------------- | ------------------------------------ |
| 스코프    | 전역 객체를 사용                         | 독립적인 파일/모듈 스코프            |
| 사용 용도 | 주로 단일 파일 내에서 코드 조직화에 사용 | 파일 간의 코드 분리 및 재사용에 적합 |
| 충돌 방지 | 충돌 가능성이 있음                       | 완전한 코드 격리로 충돌 방지 가능    |
| 예시      | 객체 기반으로 구현                       | import/export 사용                   |

### Dennis

#### ✈️ 내용 정리
네임 스페이스
- 코드 단위를 고유한 식별자로 그룹화 한 것
- 페이지 내 다른 스크립트와 변수 또는 메서드 이름이 충돌하지 않게 하기 위해 반드시 필요
- 자바스크립트는 다른 언어들처럼 네임스페이스를 기본적으로 지원하지 않지만, 객체와 클로저를 활용하여 비슷한 효과를 얻을 수 있음

네임스페이스 기초 패턴
- 단일 전역 변수 패턴
    - 즉시 실행 함수 표현식을 사용하여 클로저를 통한 스코프 분리 방법
    ```js
    const myUniqueApplication =(()=>{
        function myMethod(){
            //코드
            return;
        }
        return {
            myMethod
        }
    })()
    ```
    - 단점으로는 이미 다른 개발자가 같은 이름의 전역변수를 이미 사용하고 있을 경우 충돌난다.
- 접두사 네임스페이스 패턴
    - 변수 생성시 접두어를 붙여서 정의하는 방법으로 네임스페이스 유지
    ```js
    const myApplication_propertyA = {};
    const myApplication_propertyB = {};
    function myApplication_myMethod() {
        //...
    }
    ```
    - 다른 개발자와 같은 접두사를 전역 네임스페이스 사용하면 충돌 가능성 있음
- 객체 리터럴 표기법 패턴
    - 객체를 활용하여, 키와 값을 이루어진 집합을 사용, 각각의 키와 값은 콜로으로 구분되며 키 자체가 새로운 네임스페이스가 될 수 있음
    ```js
    const myApplication = {
        getInfo(){
            //...
        },
        models: {} // 추가 객체 네임스페이스 생성 가능
    }
    ```
    - 똑같이 이미 다른 개발자가 선언했을 수 있어서 이미 있는지 없는지 확인하여 초기화하는 로직 추가 권장
- 중첩 네임스페이스 패턴
    - 객체 리터럴 패턴을 발전시킨 형태, 객체 안에 네임스페이스를 중첩시키는 형태
    ```js
    YAHOO.util.dom.getElementsByClassName('test');
    ```
    - 이미 네임스페이스가 존재해도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문에 사용하는 패턴
- 즉시 실행 함수 표현식 패턴
    - 즉시 실행 함수 표현식(IIFE)를 통해서 메소드를 할당하는 방법
    ```js
    const namespace = namespace || {};

    ((o) => {
        o.foo = "foo";
        o.bar = () => "bar";
    })(namespace)
    ```
- 네임 스페이스 주입 패턴
    - 즉시 실행 함수의 변형 패턴
    - 함수 내에서 this를 네임스페이스의 프록시를 활용하여 특정 네임스페이스에 메서드와 속성을 주입
    ```js
    const myApp = myApp || {};
    myApp.utils = {}
    (function(){
        let val = 5;
        this.getValue = () =>
        this.setValue = (newVal) = {
            val = newVal
        }
    }).apply(myApp.utils)
    ```

고급 네임스페이스 패턴
- 중첩 네임스페이스 자동화 패턴
    - 중첩 네임스페이스의 추가하고자 하는 계층이 늘어날수록 최상위 네임스페이스에 더 많은 하위 객체를 정의해야한다는 점을 해결하기 위해 나온 방법
    ```js
    const myApp = {};

    function extend(ns, ns_string){
        const parts = ns_string.split(".");
        let parent = ns;
        let pl;

        pl = parts.length

        for(let i = 0; i < pl; i++){
            if(typeof parent[parts[i]] === "undefined"){
                parent[parts[i]] = {};
            }

            parent = parent[parts[i]]
        }
        return parent
    }

    const mod = extend(myApp, "modules.module2");
    ```
    
- 의존성 선언 패턴
    - 중첩 네임스페이스를 약간 변형한 형태, 객체의 로컬 참조가 전체적인 조회 시간을 단축시키는 사실을 사용한 방법
    ```js
    // 중첩 네임스페이스에서 접근하는 일반적인 방법
    myApp.utilities.math.fibonacci(25)

    // 로컬 변수를 통한 참조 캐싱
    const utils = myApp.utilities;
    const math = utils.math

    // 참조 캐싱된 객체를 활용
    math.fibonacci(25)
    ```
- 심층 객체 확장 패턴
    - 자동 네임스페이스 생성에 대한 또 다른 해결책
    - 객체 할당 및 재귀 호출을 사용한 심층 객체 확장 방법을 사용

#### 👀 인사이트
vuex나 pinia 등 각각의 모듈의 네임스페이스를 사용하는 라이브러리들이 이러한 패턴을 통해 구현된다는걸 깨달음
