## Day10

### Elio

#### ✈️ 내용 정리

#### 리액트 소개

- 인터페이스를 표현하는 최적화 및 간소화된 방법 제공
- 인터페이스를 컴포넌트 Props, 상태관리라는 세 가지 핵심 개념으로 나누어 정리
- 구성에 초점을 맞추고 있기 때문에 디자인 시스템의 요소들과 완벽하게 연결됨
  - 디자인 시스템은 보통 버튼, 입력 필드, 카드 같은 UI 요소를 정의한 집합
  - React의 컴포넌트는 이러한 UI 요소를 코드로 구현하고 재사용할 수 있도록 만듦
- 따라서 모듈화된 사고방식 필요

#### 리액트 기본 개념

- 컴포넌트
  - 리액트의 기본 구성 요소
  - Props를 받아서 화면에 표시할 내용을 나타내는 리액트의 요소를 반환하는 함수
- 상태
  - 컴포넌트의 라이프사이클 동안 값이 변할 수도 있는 정보를 담고 있는 객체
  - 컴포넌트가 받아온 현재 상태를 나타내기도 함
- 클라이언트 사이드 렌더링
  - 서버가 페이지의 기본 HTML 컨테이너만을 렌더링
  - 그 외 모든 작업은 자바스크립트 코드가 처리
  - CSR은 SPA을 구축하는 방법으로 인기를 얻음
  - 고도의 상호작용이 필요한 애플리케이션에 적합
- 서버 사이드 렌더링
  - 웹 콘텐츠를 렌더링하는 오래된 방법 중 하나
  - 사용자 요청에 응답하여 페이지 콘텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성
  - 리액트는 동형 렌더링이 가능해 브라우저 뿐만 아니라 서버에서도 작동 가능
  - 이에 따라 서버에서 UI 요소 렌더링 가능
- 하이드레이션
  - UI요소와 자바스크립트를 연결하는 일련의 과정

#### 고차 컴포넌트

- 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트
- 데코레이터 패턴과 유사
  - 기존 요소를 수정하지 않고 기능 확장
  - 래핑하는 방식으로 구현
  - 재사용성을 위해 사용
- 장점
  - 로직은 한 곳에 집중시킴으로써 코드를 DRY하게 유지
  - 효과적으로 관심사 분리
- 단점
  - 고차 컴포넌트가 대상 컴포넌트에 전달하는 prop의 이름은 충돌을 일으킬 수 있음

#### 렌더링 Props 패턴

- 컴포넌트를 재사용하는 또다른 패턴
- 렌더링 prop은 JSX 요소를 반환하는 함수 값을 가지는 컴포넌트의 prop
- 컴포넌트 자체는 렌더링 prop 외에는 아무것도 렌더링하지 않음
- 자신의 렌더링 로직을 구현하지 않고 렌더링 prop을 호출
- JSX를 렌더링하는 모든 prop은 렌더링 prop으로 간주됨

##### 상태 끌어올리기

- 작은 규모의 애플리케이션에서는 리덕스나 Context API 대신 상태 끌어올리기로도 충분
- 큰 규모에서는 상태 끌어올리기가 복잡해질 수 있고, 각 상태 변경 시 데이터를 사용하지 않는 자식 컴포넌트까지 리렌더링이 일어나 성능에 악영향
- 이 때 Props 렌더링 패턴으로 해결 가능
- 최상위 컴포넌트가 관리하는 상태를 필요로 하는 컴포넌트를 렌더링 props에 전달
- 이 때 최상위 컴포넌트의 render 함수에는 상태를 전달

##### 컴포넌트의 자식으로 함수 전달하기

- 최상위 컴포넌트의 자식으로 함수를 전달
- 이 함수는 jsx를 반환
- 이 때 최상위 컴포넌트에서는 자식으로 전달된 함수에 props.children으로 접근 가능

#####  장점

- 여러 컴포넌트 사이에서 로직과 데이터를 쉽게 공유 가능
- 재사용성을 높일 수 있음
- 고차 컴포넌트 사용 시 발생하는 이름 충돌 문제 해결 가능
  - props를 자동으로 병합하지 않고, 부모 컴포넌트에서 제공하는 값을 그대로 자식 컴포넌트에 전달하기 때문

##### 단점

- 라이프사이클 관련 메서드를 추가할 수 없으므로, 받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트에만 사용 가능

#### 리액트 Hooks 패턴

- 클래스 컴포넌트를 사용하지 않고도 상태와 라이프사이클 메서드 활용 가능
- Hooks는 디자인 패턴이라고 할 수는 없지만 애플리케이션 설계에서 중요한 역할을 함

##### 클래스 컴포넌트

- 생성자 함수 내의 상태
- 라이프사이클 메서드
- 추가적인 로직을 구현하기 위한 커스텀 메서드

##### 기존 문제점

- 고차 컴포넌트, 렌더링 Props 패턴을 계속 사용하게 되면 구조를 변경해야 함
- 컴포넌트들이 중첩되다보면 레퍼 헬이라는 상황에 빠져 데이터 흐름을 파악하기 어려워짐
- 클래스 컴포넌트를 사용하다보면 컴포넌트 크기는 빠르게 증가해 복잡성이 증가함
- 이로 인해 디버깅, 성능 최적화를 어렵게 만듦

##### Hooks

- 함수형 컴포넌트에 상태 추가하기
- 라이프사이클 메서드 없이도 컴포넌트의 라이프 사이클 관리하기
- 여러 컴포넌트 간에 동일한 상태 관련 로직 사용하기

#### 상태 Hook

- useState
  - 현재 상태 값
  - 상태를 업데이트하는 데 사용할 수 있는 메서드

##### 이펙트 hook

- useEffect 훅은 라이프 사이클 메서드를 하나로 합쳐 사용할 수 있음
- 의존성 배열에 상태 값을 추가하면 상태가 변할 때마다 실행됨
- useEffect는 리액트 컴포넌트가 마운트될 때 실행됨

##### Hook 관련 추가 정보

- useEffect
  - 주요 라이프사이클 이벤트 중간에 코드를 실행하는 데 사용
  - 원래 함수형 컴포넌트 내부에서는 값 변경, 구독, 타이머, 로깅, 및 기타 부수 효과를 사용할 수 없음
  - UI에 혼란스러운 버그와 오류를 초래할 수 있음
  - useEffect Hook은 이러한 부수효과를 방지하고 UI가 원활하게 실행되도록 도와줌
- useContext
  - React.createContext로 만들 수 있는 context객체를 인자로 받아 해당 context의 현재 상태에 접근 가능하게 함
  - 애플리케이션 전역에서 상태 공유 가능
  - useContext에는 반드시 context 객체 전달 필요
  - useContext를 호출하는 컴포넌트는 context 값이 변경될 때마다 리렌더링됨
- useReducer
  - setState의 대안
  - 여러 깊은 트리를 가진 복잡한 상태 로직이나 변경 이후의 상태가 이전 상태에 따라 달라지는 경우에 특히 유용함
  - reducer 함수와 초기 상태를 받아, 배열의 구조 분해 할당을 통해 현재 상태와 dispatch 함수를 반환
  - 깊은 구조를 가진 컴포넌트의 업데이트 성능을 최적화

##### Hook의 장단점

- 장점
  - 적은 코드 라인 수
  - 복잡한 컴포넌트 단순화
  - 상태 관련 로직 재사용
  - UI에서 분리된 로직 공유

#### 동적 가져오기

- 컴포넌트를 필요한 순간에 가져오기 위한 방법
- Suspense 컴포넌트와 lazy 함수 사용
  - fallback props에는 컴포넌트가 로딩되는 동안 렌더링된 컴포넌트를 전달
- SSR환경에서는 loadable-components 라이브러리 사용 가능

##### 상호작용 시 가져오기

```js
const Emoji = loadable(()=>import("./..."))
...
{pickerOpen && <EmojiPicker/>}
```

- 버튼 클릭 시 pickerOpen 상태가 바뀌면서 EmojiPicker을 동적으로 가져옴
- 이를 상호작용 시 가져오기라고 함

##### 화면에 보이는 순간 가져오기

- 이미지를 지연로딩하거나, 사용자가 스크롤해야만 화면에 나타나는 컴포넌트
- IntersectionObserver API를 사용
- react-loadable-visibillity, react-lazy-load와 같은 라이브러리 활용

#### 코드 스플리팅

- 여러 경로와 컴포넌트로 구성된 복잡한 애플리케이션에서는 적절한 시기에 정적 및 동적 임포트가 모두 가능하도록 코드를 최적으로 스플리팅하고 번들링해야 함
- 이를 위해 경로 기반 분활, 웹팩이나 롤업 등을 사용해서 처리 가능

##### 경로 기반 분할

- 특정 페이지나 경로에서만 필요한 리소스를 요청하기 위한 방법
- Suspense, loadable-components, react-router 등의 라이브러리를 같이 사용하면 처리 가능
- 페이지 이동 시 로딩 시간이 다소 걸린다는 건 많은 사람들에게 익숙하기 때문에 페이지 이동 시 컴포넌트를 지연 로딩하는 것은 자연스러운 방법

##### 번들 분할

- 최신 브라우저는 코드를 최대한 빠르고 효율적으로 파싱하고 컴파일하도록 발전했지만 요청된 데이터의 로딩 및 실행 시간 최적화는 여전히 개발자의 몫
- 메인 스레드를 차단하지 않도록 실행 시간을 최대한 단축해야 함
- 번들 분할 시 개선되는 지표
  - FCP
    - 첫 번째 콘텐츠가 사용자 화면에 표시되는 시간
  - LCP
    - 가장 큰 콘텐츠가 화면에 렌더링되는 시간
  - TTI
    - 모든 콘텐츠가 화면에 표시되고 인터렉티브해지는 시간
- 초기 로딩 시 현재 페이지에서 우선순위가 높지 않은 코드를 요청할 때는 초기 페이지 렌더링에 필요한 코드와 분리해서 로드하는 것이 좋음

#### PRPL 패턴

- 애플리케이션을 최대한 효율적으로 로드하기 위한 방법
- PRPL 패턴은 네 가지 핵심 성능 고려사항에 중점을 둠
  - 푸시
    - 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축
  - 렌더링
    - 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링
  - 사전 캐싱
    - 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험 제공
  - 지연 로딩
    - 자주 요청되지 않는 경로나 에셋은 지연 로딩
- **HTTP/1.1와 HTTP/2의 차이**
  - HTTP/1.1와 HTTP/2는 모두 TCP 통신
  - TCP는 기본적으로 양방향 통신이지만, TCP 위에서 데이터를 어떤 방식으로 주고받는지에 따라 이 기능을 제대로 활용할 수 없을 수도 있음
  - HTTP/1.1에서는 하나의 연결에서 요청이 직렬화되어 처리
  - 앞선 요청이 완료되기 전까지 뒤의 요청이 대기하는 HOL Blocking(Head-of-Line Blocking) 문제가 발생
  - HTTP/2는 멀티플렉싱(Multiplexing)을 도입하여, 하나의 연결에서 여러 요청과 응답을 동시에 처리할 수 있음
  - 이로 인해 각 요청이 독립적으로 실행되어 HOL Blocking 문제를 해결
- **서버 푸시**
  - HTTP/2는 추가로 서버 푸시라는 데이터 방식으로 도입
  - HTTP 요청을 통해 매번 명시적으로 리소스를 요청하는 대신, 서버가 이러한 리소스를 푸시하여 자동으로 추가 리소스를 전송할 수 있게 됨
  - 서버는 클라이언트의 요청에 응답할 때, 클라이언트가 나중에 필요할 리소스를 예측하여 추가로 전송 가능
  - 클라이언트가 HTML 요청을 하면, 서버는 응답에 HTML뿐만 아니라 CSS, JavaScript, 이미지 같은 리소스를 함께 푸시
  - 이에 따라 요청을 줄일 수 있음
  - HTTP/2 서버 푸시는 클라이언트가 이미 캐시된 리소스를 다시 푸시하지 않도록 설계되어 있음
  - 클라이언트는 서버가 리소스를 푸시하려 할 때, 이를 거부하거나 무시할 수 있음
- Preload
  - 브라우저에게 preload 힌트를 주게 되면 서버 푸시를 통해 해당 리소스를 발견하는 것보다 더 빨리 가져오게 됨
  - 현재 경로에 중요한 리소스를 로드하는데 걸리는 시간을 최적화하는 좋은 방법 
  - 너무 많은 파일을 푸시하면 오히려 해가 될 수 있음
    - 브라우저 캐시는 제한적
    - 클라이언트가 필요로 하지 않는 리소스를 요청하여 불필요하게 대역폭을 많이 사용할 수 있음
    - PRPL 패턴은 초기 로딩 최적화에 중점을 두기에 초기 접근 경로가 완전히 렌더링되기 전에는 다른 리소스를 로드하지 않음

##### 정리

- PRPL 패턴은 초기 접근 경로(첫 화면)에 필요한 리소스를 빠르게 로드하여 사용자가 최대한 빨리 페이지를 사용할 수 있도록 함
- 나머지 리소스는 백그라운드에서 비동기로 로드하거나 필요할 때만 가져옴
- 이를 통해 초기 로딩 성능을 크게 향상시키면서도 캐시를 효율적으로 활용

#### 로딩 우선순위

- 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정
- preload 기능을 사용
- 상호작용에 필요한 리소스를 먼저 로딩하다가 FCP 또는 LCP에 필요한 리소스 지연은 피해야 한다는 점
- 자바스크립트 자체 로딩을 최적화하려면 head 태그에서 script defer을 사용하는 것이 해당 리소스를 초기에 로딩하는데 도움이 될 수 있음
  - `script.js`는 HTML 파싱과 동시에 로드되고, HTML 파싱이 완료된 후 실행
  - 여러 개의 `defer` 스크립트는 정의된 순서대로 실행

##### Preload+async 기법

- preload로 필요한 스크립트를 먼저 다운로드하여 네트워크 지연을 최소화
- async로 스크립트 실행이 HTML 파싱을 차단하지 않으므로, 페이지 로딩 속도가 개선됨

#### 리스트 가상화

- 현재 화면에 보이는 행만 동적으로 렌더링하는 기술로 대규모 데이터 리스트의 렌더링 성능을 향상시킴
- react-virtualized와 같은 라이브러리를 사용하여 구현 가능

##### 웹 플랫폼의 발전

- 정적인 콘텐츠 목록 content-visibility 속성을 auto 값으로 설정
- 화면 밖 콘텐츠의 렌더링과 페인팅을 필요한 시점까지 지연할 수 있음
- 동적인 콘텐츠 목록을 렌더링할 때는 여전히 react-window와 같은 라이브러리를 사용하는 것이 좋음

#### 👀 인사이트

### Dennis

#### ✈️ 내용 정리

리액트 디자인 패턴
- 고차 컴포넌트 패턴(HOC)
    - 컴포넌트의 Props로 컴포넌트를 받아 새로운 컴포넌트를 반환하는 패턴
    - 장점
        - 재사용 가능 한 로직을 한 곳에 모아 관리 가능
        - 횡단 관심사 처리 가능
    - 단점
        - 인자로 받은 컴포넌트에 props를 전달할 시 중복되는 속성명을 가지고있다면 덮어씌워질 수 있음
        - 
    ```js
    import React from 'react';
    import { useNavigate } from 'react-router-dom';

    // HOC 정의
    function withAuthorization(WrappedComponent) {
    return function (props) {
        const navigate = useNavigate();
        const isAuthenticated = !!localStorage.getItem('authToken'); // 예시로 localStorage 사용

        React.useEffect(() => {
        if (!isAuthenticated) {
            alert('로그인이 필요합니다.');
            navigate('/login'); // 로그인 페이지로 리다이렉트
        }
        }, [isAuthenticated, navigate]);

        // 인증된 경우에만 원래 컴포넌트를 렌더링
        return isAuthenticated ? <WrappedComponent {...props} /> : null;
    };
    }

    // 원래 컴포넌트
    function Dashboard() {
    return <h1>대시보드에 오신 것을 환영합니다!</h1>;
    }

    // HOC를 통해 보호된 컴포넌트
    const ProtectedDashboard = withAuthorization(Dashboard);

    export default ProtectedDashboard;
    ```
- 렌더링 Props 패턴
    - 랜더링 props를 호출하는 함수를 생성하고 props를 통해서 랜더링할 컴포넌트를 받아서 처리하는 패턴
    - 장점
        - 여러 컴포넌트 사이에 로직과 데이터를 쉽게 공유할 수 있음
        - 컴포넌트 재사용성 높일 수 있음
        - 고차 컴포넌트의 이름 충돌 문제 해결
    - 단점
        - Hooks가 props 패턴의 상위 호환 
        - 라이프 사이클 메서드를 추가할 수 없음
    ```jsx
    <Title render={()=><h1> am a render prop!</h1>} />

    const Title = props => props.render()
    ```
    - 리액트에서는 상태 끌어올리를 통해서 자식의 상태를 부모에게 전달하는데 해당 과정을 줄일 수 있음
    ```jsx
    <Input>
        render={(value) => (
                <>
                    <Kelvin value={value} />
                    <Fahrenheit value={value} />
                </>
            )
        }
    ```
- Hooks 패턴
    - 컴포넌트간에 로직을 재사용하기 위해 등장 
    - 함수형 컴포넌트에 상태 추가 가능
    - 함수형 컴포넌트에서 라이프 사이클 메서드 사용 가능
    - useState, useEffect 등등
- 정적 가져오기
    - 일반적인 import 통한 컴포넌트 참조 방법
    - import 와 동시에 단일 번들링에 포함되어 번들 사이즈를 크게 만들 수 있음
- 동적 가져오기
    - Suspense와 lazy를 통하여 코드 스플리팅을 통해 동적으로 가져옴
    - 동적으로 가져오면 렌더링이 필요할때 필요한 코드 조각만 가져올 수 있음
    - SSR 환경에서 Suspense를 지원하지 않을때 (리액트 18 이전) 대안으로 Loadable-components라는 라이브러리를 사용
- 코드 스플리팅
    - 경로 별로 코드 스플리팅 하여 초기 로딩을 줄이는걸 권장
    - 번들 분할
        - 장점
            - 첫 콘텐츠가 사용자 화면에 표시되는 시간(FCP)을 단축시킴
            - 가장 큰 콘텐츠가 화면에 랜더링 되는 시간 (LCP) 지표 개선선
- PRPL(push Render Pre-cache Lazy-load) 패턴
    - 저사양 기기나 인터넷이 불안정한 지역에서도 애플리케이션을 최대한 효율적으로 로드 될 수 있게 하는 패턴
        - 핵심  고려사항
            - 푸시 : 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축시킴
                - 브라우저는 어떤 리소스가 중요한지 모르니 preload를 통해 중요한 리소스를 로드하는 시간을 최적화화
                ```html
                <link rel="preload" href="/main.js" as="script">
                <link rel="preload" href="/styles.css" as="style">
                ```
            - 렌더링 : 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링
                - SSR(Server-Side Rendering) 또는 CSR(Client-Side Rendering)을 사용하여 콘텐츠를 빠르게 렌더링
            - 사전 캐싱 : 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공
            ```js
            self.addEventListener('install', event => {
            event.waitUntil(
                caches.open('my-cache').then(cache => {
                return cache.addAll([
                    '/index.html',
                    '/main.js',
                    '/styles.css',
                    '/image.png'
                ]);
                })
            );
            });
            ```
            - 지연 로딩 : 자주 요청되지 않는 경로나 에셋은 지연 로딩
            ```js
            <img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy" alt="Lazy loaded image">
            ```
    - 초기 로드 후 서비스 워커를 사용하여 해당 리소스를 캐시함
    - 패턴이라기 보단 개발 방법론 같음
- 로딩 우선순위
    - 로딩 우선순위 패턴은 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도로 설정
    - SPA의 Preload
        - webpack 의 preload 기능을 통해서 js에서 preload 컴포넌트 지정 가능
        ```js
        const EmojiPicker = import(/* webpackPreload: true */ "./EmojiPicker")

        // 빌드 결과
        <link rel="prefetch" href="emoji-picker.bundle.js" as="script">
        ```
    - Preload + async 기법
        - 스크립트를 높은 우선순위로 다운로드하면서도, 스크립트를 기다리는 동안 파싱이 멈추지 않도록 하기 위한 방법
        ```html
        <link rel="preload" href="emoji-picker.js" as="script" />

        <script src="emoji-picker.js" async></script>
        ```
- 리스트 가상화
    - 대규모 데이터를 렌더링해야할때 보이는 영역만 먼저 동적으로 렌더링하는 기술
    - 리액트에서는 `react-virtualized`, `react-window` 라이브러리를 사용하여 구현 간소화화
    - 최신 브라우저에서는 `content-visibility` CSS 속성을 통해서 화면 밖 콘텐츠와 페인팅이 필요한 시점까지 지연 가능
        

#### 👀 인사이트

HTTP/1.1 에서는 클라이언트와 서버 간의 연결이 최대 6개
- 이런 문제를 통해 blocking 되는 경우 HOL Blocking 이라고함


Magic Comments

- 아래 코드와 같이 웹팹에서 번들링 되기전 주석으로 옵션을 줄 수 있는지 처음알았음
정식 명칭은 Webpack의 import 문법의 [Magic Comments](https://webpack.kr/api/module-methods/#magic-comments) 라고함
    ```js
    const EmojiPicker = import(/* webpackPreload: true */ "./EmojiPicker")

    // 빌드 결과
    <link rel="prefetch" href="emoji-picker.bundle.js" as="script">
    ```