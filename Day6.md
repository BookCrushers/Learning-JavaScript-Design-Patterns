## Day6

### Elio

#### ✈️ 내용 정리

#### MVC 패턴

- 애플리케이션 구조 개선을 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴
- 비즈니스 데이터(모델)와 UI(뷰)를 분리, 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리

##### 모델

- 애플리케이션의 데이터를 관리
- 애플리케이션에 필요한 고유 데이터 형식
- 모델이 변경될 때 관찰자에게 변경사항을 알림

##### 뷰

- 모델에 대한 시각적인 표현
- 현재 상태의 특정 부분만 보여줌
- 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받음
- 이를 통해 뷰는 스스로를 업데이트
- 사용자는 뷰를 통해 상호작용 가능
- 템플릿
  - 템플릿은 뷰를 생성하기 위해 사용될 수 있음

##### 컨트롤러

- 모델과 뷰 사이의 중재자 역할을 하며, 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할을 함

##### MVC 장점

- 전반적인 유지보수의 단순화
- 모델과 뷰의 분리
- 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복 제거 가능
- 모듈화를 통해 여러 개발자들의 동시 작업이 가능

#### MVP 패턴

- 프레젠테이션 로직 개선에 초점을 맞춘 MVC 디자인 패턴의 파생

##### 모델, 뷰, 프리젠터

- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소
- MVC와 달리 뷰에서의 이벤트 호출은 프리젠터로 위임됨
- 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신
- 장점
  - 애플리케이션의 테스트 용이성을 높임
  - 뷰와 모델간의 분리를 더욱 명확하게 해줌
- 단점
  - 데이터 바인딩이 지원되지 않아 작업을 별도로 처리 필요
    - MVC에서는 모델이 뷰를 관찰하고 있음

##### MVP VS MVC

- MVP
  - 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션
  - 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션
  - 프리젠터를 UI의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트 가능

#### MVVM

- MVC와 MVP 기반으로 하는 아키텍처 패턴
- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확히 분리
- 구성 요소
  - 모델
    - 도메인에 관련된 정보를 전달
  - 뷰
    - 사용자 인터페이스
  - 뷰모델
    - 모델과 뷰 사이의 인터페이스 역할

##### 모델

- 다른 MV*패턴과 마찬가지로 애플리케이션이 사용할 도메인 관련 데이터나 정보
- 모델은 보통 정보를 담고 있음, 동작을 담고 있지 않음
- 정보 형식을 지정하지 않음, 이는 뷰의 역할
- 동작은 모델과 상호작용하는 또 다른 계층인 뷰모델에서 캡슐화하여 처리해야 하는 비즈니스 로직
- 모델의 역할 중 유일한 예외는 데이터 유효성 검사

##### 뷰

- 뷰는 애플리케이션에서 사용자가 상호작용하는 유일한 부분
- 뷰 모델의 상태를 표현하는 상호작용이 가능한 UI
- 이런 면에서 뷰는 수동적이라기보다는 능동적
- 수동적 뷰는 단순히 화면을 출력할 뿐 사용자의 입력을 받아들이지 않음
- 뷰는 상태를 관리할 책임이 없음
- 뷰는 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지

##### 뷰모델

- 데이터 변환기의 역할을 하는 특수한 컨트롤러
- 동작
  - 뷰의 상태 유지
  - 뷰에서 발생한 동작에 기반해 모델을 업데이트
  - 뷰에 이벤트 발생시키기
- 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있음
- 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있음

##### 장단점

- 장점
  - UI, 코어 로직 동시 개발 가능
  - 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여줌
  - 이벤트 중심 코드에 비해 단위 테스트가 쉬움
  - 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능
- 단점
  - 단순한 UI일 경우 과도한 패턴
  - 데이터 바인딩은 선언적이고 사용하기 편리할 수 있으나 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅 어려움
  - 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들어낼 수 있음
  - 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있음

#### MVC vs MVP vs MVVM

- MVP, MVVM 모두 MVC에서 파생된 패턴
- 차이 기준
  - 각 계층이 다른 계층에 대해 갖는 의존성
  - 결합성
- MVC 패턴에서 전체 모델을 뷰에 노출하는 문제점을 피하기 위해 MVVM 등장

#### 👀 인사이트

- https://012.vuejs.org/guide/
- MVP와 MVVM 차이

| **항목**             | **프레젠터 (MVP)**                   | **뷰모델 (MVVM)**                         |
| -------------------- | ------------------------------------ | ----------------------------------------- |
| **뷰와의 관계**      | 뷰를 직접 알고, 호출함               | 뷰를 알지 못하고, 데이터 바인딩 사용      |
| **데이터 전달 방식** | 명시적 메서드 호출                   | 데이터 바인딩 또는 옵저버 패턴            |
| **결합도**           | 뷰와 프레젠터가 강하게 결합됨        | 뷰와 뷰모델이 느슨하게 결합됨             |
| **테스트 용이성**    | 인터페이스 기반으로 테스트가 용이함  | 데이터 바인딩을 테스트하기 복잡할 수 있음 |
| **적용성**           | 데이터 바인딩이 없는 환경에서도 적합 | 데이터 바인딩 기술이 필요                 |

---

### Dennis

#### ✈️ 내용 정리

#### 👀 인사이트

