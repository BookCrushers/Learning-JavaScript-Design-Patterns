## Day6

### Elio

#### ✈️ 내용 정리

#### MVC 패턴

- 애플리케이션 구조 개선을 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴
- 비즈니스 데이터(모델)와 UI(뷰)를 분리, 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리

##### 모델

- 애플리케이션의 데이터를 관리
- 애플리케이션에 필요한 고유 데이터 형식
- 모델이 변경될 때 관찰자에게 변경사항을 알림

##### 뷰

- 모델에 대한 시각적인 표현
- 현재 상태의 특정 부분만 보여줌
- 뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받음
- 이를 통해 뷰는 스스로를 업데이트
- 사용자는 뷰를 통해 상호작용 가능
- 템플릿
  - 템플릿은 뷰를 생성하기 위해 사용될 수 있음

##### 컨트롤러

- 모델과 뷰 사이의 중재자 역할을 하며, 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할을 함

##### MVC 장점

- 전반적인 유지보수의 단순화
- 모델과 뷰의 분리
- 애플리케이션 전반에서 하위 수준의 모델 및 컨트롤러 코드 중복 제거 가능
- 모듈화를 통해 여러 개발자들의 동시 작업이 가능

#### MVP 패턴

- 프레젠테이션 로직 개선에 초점을 맞춘 MVC 디자인 패턴의 파생

##### 모델, 뷰, 프리젠터

- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소
- MVC와 달리 뷰에서의 이벤트 호출은 프리젠터로 위임됨
- 프리젠터는 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신
- 장점
  - 애플리케이션의 테스트 용이성을 높임
  - 뷰와 모델간의 분리를 더욱 명확하게 해줌
- 단점
  - 데이터 바인딩이 지원되지 않아 작업을 별도로 처리 필요
    - MVC에서는 모델이 뷰를 관찰하고 있음

##### MVP VS MVC

- MVP
  - 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션
  - 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션
  - 프리젠터를 UI의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트 가능

#### MVVM

- MVC와 MVP 기반으로 하는 아키텍처 패턴
- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확히 분리
- 구성 요소
  - 모델
    - 도메인에 관련된 정보를 전달
  - 뷰
    - 사용자 인터페이스
  - 뷰모델
    - 모델과 뷰 사이의 인터페이스 역할

##### 모델

- 다른 MV*패턴과 마찬가지로 애플리케이션이 사용할 도메인 관련 데이터나 정보
- 모델은 보통 정보를 담고 있음, 동작을 담고 있지 않음
- 정보 형식을 지정하지 않음, 이는 뷰의 역할
- 동작은 모델과 상호작용하는 또 다른 계층인 뷰모델에서 캡슐화하여 처리해야 하는 비즈니스 로직
- 모델의 역할 중 유일한 예외는 데이터 유효성 검사

##### 뷰

- 뷰는 애플리케이션에서 사용자가 상호작용하는 유일한 부분
- 뷰 모델의 상태를 표현하는 상호작용이 가능한 UI
- 이런 면에서 뷰는 수동적이라기보다는 능동적
- 수동적 뷰는 단순히 화면을 출력할 뿐 사용자의 입력을 받아들이지 않음
- 뷰는 상태를 관리할 책임이 없음
- 뷰는 뷰모델과 정보 또는 상태를 항상 동기화된 상태로 유지

##### 뷰모델

- 데이터 변환기의 역할을 하는 특수한 컨트롤러
- 동작
  - 뷰의 상태 유지
  - 뷰에서 발생한 동작에 기반해 모델을 업데이트
  - 뷰에 이벤트 발생시키기
- 데이터 바인딩을 위해 모델 또는 모델의 속성을 가져올 수 있음
- 뷰에 제공되는 속성을 가져오거나 조작하기 위한 인터페이스를 포함할 수 있음

##### 장단점

- 장점
  - UI, 코어 로직 동시 개발 가능
  - 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여줌
  - 이벤트 중심 코드에 비해 단위 테스트가 쉬움
  - 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능
- 단점
  - 단순한 UI일 경우 과도한 패턴
  - 데이터 바인딩은 선언적이고 사용하기 편리할 수 있으나 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅 어려움
  - 복잡한 애플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들어낼 수 있음
  - 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 어려울 수 있음

#### MVC vs MVP vs MVVM

- MVP, MVVM 모두 MVC에서 파생된 패턴
- 차이 기준
  - 각 계층이 다른 계층에 대해 갖는 의존성
  - 결합성
- MVC 패턴에서 전체 모델을 뷰에 노출하는 문제점을 피하기 위해 MVVM 등장

#### 👀 인사이트

- https://012.vuejs.org/guide/
- MVP와 MVVM 차이

| **항목**             | **프레젠터 (MVP)**                   | **뷰모델 (MVVM)**                         |
| -------------------- | ------------------------------------ | ----------------------------------------- |
| **뷰와의 관계**      | 뷰를 직접 알고, 호출함               | 뷰를 알지 못하고, 데이터 바인딩 사용      |
| **데이터 전달 방식** | 명시적 메서드 호출                   | 데이터 바인딩 또는 옵저버 패턴            |
| **결합도**           | 뷰와 프레젠터가 강하게 결합됨        | 뷰와 뷰모델이 느슨하게 결합됨             |
| **테스트 용이성**    | 인터페이스 기반으로 테스트가 용이함  | 데이터 바인딩을 테스트하기 복잡할 수 있음 |
| **적용성**           | 데이터 바인딩이 없는 환경에서도 적합 | 데이터 바인딩 기술이 필요                 |

---

### Dennis

#### ✈️ 내용 정리

애플리케이션 설계에는 객체의 설계와 애플리케이션 아키텍처라는 두 가지 중요한 측면이 있다.

이전까지 학습한 내용은 객체의 설계에 관련된 내용이며 다음 내용은 애플리케이션 아케텍처에 관한 이야기이다.

**MVC패턴**

비즈니스 데이터(Model)과 UI(View)를 분리하고 Controller가 로직과 사용자의 입력을 관리하는 구조
- 관찰자 패턴이 MVC 아키텍처의 일부로 포함됨 (뷰가 모델을 관찰함)
- 뷰는 **모델을 관찰하고 시각적 표현(UI)를 최신 상태로 유지하는 객체**
- 컨트롤러는 모델과 뷰 사이에 중재자 역할을 하며, 일반적으로 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할을 함
- MVC 패턴을 사용하는 이유
  - 전반적인 유지보수의 단순화 : 애플리케이션을 업데이트 해야할 때, 변경사항이 모델과 컨트롤러에 의한 데이터 중심인지, 단순히 시각적 변경인지 명확하게 구분 가능
  - 모델과 뷰의 분리 : 비즈니스 로직에 대한 단위 테스트가 간편해짐
  - 애플리케이션 전반에 하위 수준의 모델 및 컨트롤러 코드 중복이 제거됨
  - 모듈화를 통해 코어 로직 담당자와 UI 개발자가 동시에 작업 가능 (협업 향상)
- MVC 패턴의 다른 관점
  - GoF에서는 MVC를 디자인 패턴이 아닌** UI를 구축하기 위한 클래스들의 집합**으로 간주함
  - 또한 MVC는 관찰자, 전략, 컴포지트의 세가지 전통적인 패턴의 변형이라 판단
**MVP패턴**

프레젠테이션 로직의 개선에 초점을 맞춘 MVC패턴의 파생 패턴
- 모델, 뷰, 프리젠터로 이루어져있음
- 프리젠터는 뷰에 대한 UI 비즈니스 로직을 담당하며, 이벤트 호출은 뷰에서 프리젠터로 위임됨
- MVP는 주로 수동형 뷰를 활용하는 구현 방식으로 가장 널리 사용됨
- 프리젠터는 모델을 관찰하고 모델이 변경되면 뷰를 업데이트함
```kotlin
// View Interface
interface LoginView {
    fun showLoading()           // 로딩 표시
    fun hideLoading()           // 로딩 숨김
    fun showError(message: String)  // 에러 메시지 표시
    fun navigateToHome()        // 홈 화면으로 이동
}
```
```kotlin
// Presenter Interface
interface LoginPresenter {
    fun onLoginButtonClicked(username: String, password: String)
}
```
```kotlin
class LoginPresenterImpl(private val view: LoginView) : LoginPresenter {

    override fun onLoginButtonClicked(username: String, password: String) {
        if (username.isEmpty() || password.isEmpty()) {
            view.showError("Username or Password cannot be empty")
            return
        }

        view.showLoading()
        // 로그인 로직 처리 (예: 서버 요청)
        // 여기서는 간단히 성공/실패 시나리오를 가정
        val isSuccess = username == "user" && password == "pass"

        view.hideLoading()
        if (isSuccess) {
            view.navigateToHome()
        } else {
            view.showError("Invalid credentials")
        }
    }
}

```
**MVVM패턴**

- 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리함
- 구성요소
  - 모델
  - 뷰
  - 뷰 모델
- 많은 MVVM 패턴에서 선언적 데이터 바인딩을 활용하여 뷰에 대한 작업을 다른 계층과 분리할 수 있도록 함
- 뷰는 상태를 관리할 책임이 없다. 뷰는 뷰 모델과 정보 또는 상태를 항상 동기화된 상태로 유지하기 때문이다.
- 뷰 모델은 생각해보니 스토어와 유사하다는 생각이 듦
- 장점
  - UI와 이를 구동하게 해주는 요소를 동시 개발할 수 있음
  - 뷰를 추상화함으로 써 뷰의 뒤에 작성되는 비즈니스 로직의 양으 줄여줌
  - 뷰모델은 이벤트 중심 코드에 비해 단위 테스트가 더 쉬움
  - 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이 테스트 가능
- 단점
  - 단순한 UI에 적합하지 않음, 과도한 구현이 될 수 있음
  - 데이터 바인딩은 선언적이고 편리하지만, 디버깅이 어려울 수 있음
  - 데이터 바인딩이 상당한 관리 부담으로 이루어질 수 있음
  - 대규모 애플리케이션에서 일반화를 제공하기위한 뷰모델을 설계하는게 어려울 수 있음
  

**MVC vs MVP**
- MVP는 일반적으로 프리젠테이션 로직을 최대한 활용해야하는 엔터프라이즈 수준의 애플리케이션에서 사용
- 뷰가 매우 복잡하고 사용자와의 상호작용이 많다면 MVC가 적합하지 않을 수 있음
- MVC 패턴은 컨트롤러가 모델과 뷰를 이어주면서 결합도가 비교적으로 있음
- MVP 패턴은 뷰와 모델의 완전한 분리를 목표로 함, 때문에 단위 테스트가 편해짐


#### 👀 인사이트

**Smalltalk-80**
- 1970년대 초 미국 제록스(XEROX)사에서 개발된 객체 지향 프로그래밍(OOP) 분야에서 기초적인 아이디어를 제시한 언어
